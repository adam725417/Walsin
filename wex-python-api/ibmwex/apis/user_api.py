# coding: utf-8

"""
    WEX REST APIs

    Authentication methods - Basic Auth - JSON Web Token   - [POST /api/v1/usermgmt/login](#!/User/signinUser)   - [POST /api/v1/usermgmt/logout](#!/User/doLogout) - Python client sample [Download](/docs/wex-python-api.zip) 

    OpenAPI spec version: 12.0.2.417
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class UserApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def change_my_password(self, password, **kwargs):
        """
        Helps the user change his password
        Only if external LDAP is not setup
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.change_my_password(password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str password: The new password for the currently logged in user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.change_my_password_with_http_info(password, **kwargs)
        else:
            (data) = self.change_my_password_with_http_info(password, **kwargs)
            return data

    def change_my_password_with_http_info(self, password, **kwargs):
        """
        Helps the user change his password
        Only if external LDAP is not setup
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.change_my_password_with_http_info(password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str password: The new password for the currently logged in user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_my_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'password' is set
        if ('password' not in params) or (params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `change_my_password`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'password' in params:
            form_params.append(('password', params['password']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/user/changemypassword', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def change_user_password(self, username, password, **kwargs):
        """
        Helps the admin change user's password
        Only if external LDAP is not setup
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.change_user_password(username, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The username for user that needs new password (required)
        :param str password: The new password for the currently logged in user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.change_user_password_with_http_info(username, password, **kwargs)
        else:
            (data) = self.change_user_password_with_http_info(username, password, **kwargs)
            return data

    def change_user_password_with_http_info(self, username, password, **kwargs):
        """
        Helps the admin change user's password
        Only if external LDAP is not setup
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.change_user_password_with_http_info(username, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The username for user that needs new password (required)
        :param str password: The new password for the currently logged in user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_user_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `change_user_password`")
        # verify the required parameter 'password' is set
        if ('password' not in params) or (params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `change_user_password`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'username' in params:
            form_params.append(('username', params['username']))
        if 'password' in params:
            form_params.append(('password', params['password']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/user/changeuserpassword', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_user(self, body, **kwargs):
        """
        Create user (or Grant Access if an External LDAP is present 
        This can only be done by a user with an admin role. The admin would provide the user's details and if LDAP is setup, also select if the user is to be authenticated by LDAP or by our internal repo. If External LDAP is picked as an authenticator for the user, password should not be prompted for - since the Admin will not have the user's password. Else, if the internal authenticator is used, the password would be an initial default - which the user can change after they login. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_user(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param User body: Create user object (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_user_with_http_info(body, **kwargs)
        else:
            (data) = self.create_user_with_http_info(body, **kwargs)
            return data

    def create_user_with_http_info(self, body, **kwargs):
        """
        Create user (or Grant Access if an External LDAP is present 
        This can only be done by a user with an admin role. The admin would provide the user's details and if LDAP is setup, also select if the user is to be authenticated by LDAP or by our internal repo. If External LDAP is picked as an authenticator for the user, password should not be prompted for - since the Admin will not have the user's password. Else, if the internal authenticator is used, the password would be an initial default - which the user can change after they login. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_user_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param User body: Create user object (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_user`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/user', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_config_file(self, name, **kwargs):
        """
        Delete config file
        _**Needs Admin role**_ Delete config file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_config_file(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: File name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_config_file_with_http_info(name, **kwargs)
        else:
            (data) = self.delete_config_file_with_http_info(name, **kwargs)
            return data

    def delete_config_file_with_http_info(self, name, **kwargs):
        """
        Delete config file
        _**Needs Admin role**_ Delete config file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_config_file_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: File name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_config_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_config_file`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/config/file/{name}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_user(self, username, **kwargs):
        """
        Delete user
        This can only be done by an admin. Note the initial 'admin' user cannot be deleted
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_user(username, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The name that needs to be deleted (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_user_with_http_info(username, **kwargs)
        else:
            (data) = self.delete_user_with_http_info(username, **kwargs)
            return data

    def delete_user_with_http_info(self, username, **kwargs):
        """
        Delete user
        This can only be done by an admin. Note the initial 'admin' user cannot be deleted
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_user_with_http_info(username, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The name that needs to be deleted (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `delete_user`")


        collection_formats = {}

        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/user/{username}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def do_logout(self, **kwargs):
        """
        Logs out current logged in user from session
        should only be shown when the user is logged in. The generated JWT token should be deleted from the repo as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.do_logout(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.do_logout_with_http_info(**kwargs)
        else:
            (data) = self.do_logout_with_http_info(**kwargs)
            return data

    def do_logout_with_http_info(self, **kwargs):
        """
        Logs out current logged in user from session
        should only be shown when the user is logged in. The generated JWT token should be deleted from the repo as well. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.do_logout_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method do_logout" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/logout', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_admin_patterms(self, **kwargs):
        """
        Get list of pattern texts to make user as Admin
        _**Needs Admin role**_ Get list of pattern texts to make user as Admin. See [POST /api/v1/usermgmt/config/admin](#!/User/putAdminPatterns) 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_admin_patterms(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[GroupPattern]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_admin_patterms_with_http_info(**kwargs)
        else:
            (data) = self.get_admin_patterms_with_http_info(**kwargs)
            return data

    def get_admin_patterms_with_http_info(self, **kwargs):
        """
        Get list of pattern texts to make user as Admin
        _**Needs Admin role**_ Get list of pattern texts to make user as Admin. See [POST /api/v1/usermgmt/config/admin](#!/User/putAdminPatterns) 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_admin_patterms_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[GroupPattern]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_patterms" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/config/admin', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[GroupPattern]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_config_file(self, name, **kwargs):
        """
        Get config file
        _**Needs Admin role**_ Get content of a config file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_config_file(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: File name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_config_file_with_http_info(name, **kwargs)
        else:
            (data) = self.get_config_file_with_http_info(name, **kwargs)
            return data

    def get_config_file_with_http_info(self, name, **kwargs):
        """
        Get config file
        _**Needs Admin role**_ Get content of a config file 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_config_file_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: File name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_config_file`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/octet-stream'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/config/file/{name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_current_user_info(self, **kwargs):
        """
        Get current user info
        Get current user info. No sensitive info - not even the password hash
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_current_user_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_current_user_info_with_http_info(**kwargs)
        else:
            (data) = self.get_current_user_info_with_http_info(**kwargs)
            return data

    def get_current_user_info_with_http_info(self, **kwargs):
        """
        Get current user info
        Get current user info. No sensitive info - not even the password hash
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_current_user_info_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_user_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/user/currentUserInfo', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='User',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_user_by_name(self, username, **kwargs):
        """
        Get user details by user name
        If admin, then can retrieve any user info. Otherwise, only current user's info.  In any case, no sensitive info - not even the password hash
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_name(username, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The name that needs to be fetched (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_user_by_name_with_http_info(username, **kwargs)
        else:
            (data) = self.get_user_by_name_with_http_info(username, **kwargs)
            return data

    def get_user_by_name_with_http_info(self, username, **kwargs):
        """
        Get user details by user name
        If admin, then can retrieve any user info. Otherwise, only current user's info.  In any case, no sensitive info - not even the password hash
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_by_name_with_http_info(username, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The name that needs to be fetched (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `get_user_by_name`")


        collection_formats = {}

        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/user/{username}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='User',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def list_config_file(self, **kwargs):
        """
        List config files
        _**Needs Admin role**_ List config files 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_config_file(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[ConfigFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_config_file_with_http_info(**kwargs)
        else:
            (data) = self.list_config_file_with_http_info(**kwargs)
            return data

    def list_config_file_with_http_info(self, **kwargs):
        """
        List config files
        _**Needs Admin role**_ List config files 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_config_file_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: list[ConfigFile]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_config_file" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/config/file/', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[ConfigFile]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def list_users(self, **kwargs):
        """
        Get all users
        Gets `User` objects. Optional query param of **includeAll** determines whether to include user entries that are in pending or  denied state else only access-granted users will be returned.  _**Needs Admin role**_ no sensitive info - not even the password hash returned 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_users(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool include_all: set to true to include users in pending/denied access states too
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_users_with_http_info(**kwargs)
        else:
            (data) = self.list_users_with_http_info(**kwargs)
            return data

    def list_users_with_http_info(self, **kwargs):
        """
        Get all users
        Gets `User` objects. Optional query param of **includeAll** determines whether to include user entries that are in pending or  denied state else only access-granted users will be returned.  _**Needs Admin role**_ no sensitive info - not even the password hash returned 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_users_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param bool include_all: set to true to include users in pending/denied access states too
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_all']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_users" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_all' in params:
            query_params.append(('includeAll', params['include_all']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/users', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[User]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def put_admin_patterns(self, **kwargs):
        """
        Put list of pattern texts to make user as Admin
        _**Needs Admin role**_ Set list of pattern texts to make user as Admin. For each patterns, each user and groups are evaluated. Once pattern matches, user will be Admin (allow=true) or User(allow=false). If not of pattern matches any of user's group, user's role is set as \"User\" 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_admin_patterns(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[GroupPattern] body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.put_admin_patterns_with_http_info(**kwargs)
        else:
            (data) = self.put_admin_patterns_with_http_info(**kwargs)
            return data

    def put_admin_patterns_with_http_info(self, **kwargs):
        """
        Put list of pattern texts to make user as Admin
        _**Needs Admin role**_ Set list of pattern texts to make user as Admin. For each patterns, each user and groups are evaluated. Once pattern matches, user will be Admin (allow=true) or User(allow=false). If not of pattern matches any of user's group, user's role is set as \"User\" 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.put_admin_patterns_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[GroupPattern] body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_admin_patterns" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/config/admin', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def signin_user(self, username, password, **kwargs):
        """
        Logs user into the system
        This option should only be shown if the user is not already logged in.  If external LDAP is used as the authenticator for this user record , the login method will delegate the username/password validation to that ldap host. Else it would generate the 1-way hash using the supplied password and compare it with the hash stored in the repo for that user.  As part of the login flow, a JWT token will be generated with the username, role, a refresh_timestamp in the payload. This would also be stored in the cloudant repo. It will also be set as a cookie to keep track of the user's session.  The refresh_timestamp will be used later on to verify if the user's record is still current & if so, regenerate the JWT token. This cycle repeats at regular intervals on user http requests. If the user is idle or has closed off his browser - the cookie will become invalid since the refresh timestamp would have expired & the customer would need to re-sign in.   Once sign in is complete, if the request is complete, the user's browser is redirected to the URL that they were in previously before being redirected to sign in page.   Sign-in Variation: We should also support the standard Basic Auth for REST API. The user can provide a Authorization: Basic base64-ed header when requesting a target URL.We would need to seamlessly validate their Basic Auth credentials and continue their request to their target URL. Note: We cannot throw a 302 redirect like we would to the browser.  To this end, we would have an internal REST function (say /user/validateAuth) that is invoked by the nginx proxy when it encounters the Basic Auth header to validate the credentials. This function would return the JWT token and a 200 for success. On failure, returns a 401 with error messages just like /user/signin.  The nginx proxy, on success, would proxy_pass the request to the requested target URL.   Lockout Policy: (v2 Candidate) If the number of login attempts (recent_number_of_failed_attempts) exceed 'policy_numfailedattempts' within the last 'policy_numfailedattempts_timeperiod' minutes, then lock the user account for 30 minutes. If after that time, the user tries again, the lock is released 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signin_user(username, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The user name for login (required)
        :param str password: The password for login in clear text (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.signin_user_with_http_info(username, password, **kwargs)
        else:
            (data) = self.signin_user_with_http_info(username, password, **kwargs)
            return data

    def signin_user_with_http_info(self, username, password, **kwargs):
        """
        Logs user into the system
        This option should only be shown if the user is not already logged in.  If external LDAP is used as the authenticator for this user record , the login method will delegate the username/password validation to that ldap host. Else it would generate the 1-way hash using the supplied password and compare it with the hash stored in the repo for that user.  As part of the login flow, a JWT token will be generated with the username, role, a refresh_timestamp in the payload. This would also be stored in the cloudant repo. It will also be set as a cookie to keep track of the user's session.  The refresh_timestamp will be used later on to verify if the user's record is still current & if so, regenerate the JWT token. This cycle repeats at regular intervals on user http requests. If the user is idle or has closed off his browser - the cookie will become invalid since the refresh timestamp would have expired & the customer would need to re-sign in.   Once sign in is complete, if the request is complete, the user's browser is redirected to the URL that they were in previously before being redirected to sign in page.   Sign-in Variation: We should also support the standard Basic Auth for REST API. The user can provide a Authorization: Basic base64-ed header when requesting a target URL.We would need to seamlessly validate their Basic Auth credentials and continue their request to their target URL. Note: We cannot throw a 302 redirect like we would to the browser.  To this end, we would have an internal REST function (say /user/validateAuth) that is invoked by the nginx proxy when it encounters the Basic Auth header to validate the credentials. This function would return the JWT token and a 200 for success. On failure, returns a 401 with error messages just like /user/signin.  The nginx proxy, on success, would proxy_pass the request to the requested target URL.   Lockout Policy: (v2 Candidate) If the number of login attempts (recent_number_of_failed_attempts) exceed 'policy_numfailedattempts' within the last 'policy_numfailedattempts_timeperiod' minutes, then lock the user account for 30 minutes. If after that time, the user tries again, the lock is released 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.signin_user_with_http_info(username, password, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The user name for login (required)
        :param str password: The password for login in clear text (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'password']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signin_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `signin_user`")
        # verify the required parameter 'password' is set
        if ('password' not in params) or (params['password'] is None):
            raise ValueError("Missing the required parameter `password` when calling `signin_user`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'username' in params:
            form_params.append(('username', params['username']))
        if 'password' in params:
            form_params.append(('password', params['password']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/api/v1/usermgmt/login', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_user(self, username, body, **kwargs):
        """
        Update user record (including his password/hash)
        This can only be done by an admin
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user(username, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: name that need to be updated (required)
        :param User body: Updated user object (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_user_with_http_info(username, body, **kwargs)
        else:
            (data) = self.update_user_with_http_info(username, body, **kwargs)
            return data

    def update_user_with_http_info(self, username, body, **kwargs):
        """
        Update user record (including his password/hash)
        This can only be done by an admin
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_user_with_http_info(username, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: name that need to be updated (required)
        :param User body: Updated user object (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `update_user`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_user`")


        collection_formats = {}

        path_params = {}
        if 'username' in params:
            path_params['username'] = params['username']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/user/{username}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def upload_config_file(self, name, **kwargs):
        """
        Upload config file
        _**Needs Admin role**_ Upload single configuratil file to the server. Attributes \"password\", \"bindPassword\" and \"keysPassword\" will be encoded by aes if XML file under 1MB. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_config_file(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: File name (required)
        :param bool no_encode: true to disable encode passwords
        :param str content: Content of a file
        :return: ConfigFile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_config_file_with_http_info(name, **kwargs)
        else:
            (data) = self.upload_config_file_with_http_info(name, **kwargs)
            return data

    def upload_config_file_with_http_info(self, name, **kwargs):
        """
        Upload config file
        _**Needs Admin role**_ Upload single configuratil file to the server. Attributes \"password\", \"bindPassword\" and \"keysPassword\" will be encoded by aes if XML file under 1MB. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_config_file_with_http_info(name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str name: File name (required)
        :param bool no_encode: true to disable encode passwords
        :param str content: Content of a file
        :return: ConfigFile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'no_encode', 'content']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_config_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `upload_config_file`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'no_encode' in params:
            query_params.append(('noEncode', params['no_encode']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'content' in params:
            body_params = params['content']
        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/usermgmt/config/file/{name}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ConfigFile',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def user_sign_up(self, username, display_name, **kwargs):
        """
        User requesting access
        This option should only be shown if the user is not already logged in. The use provides their username and password.  We first validate if they have already signed up and if so - we show whether their status is pending/denied/approved etc.  If its ExternalLDAP - then we would validate that their entry exists in LDAP, by doing an ldap bind with their creds.  The user record is stored with 'approval_status' set to 'pending', for an admin to approve.  The config setting 'auto_signup' that automatically approves all signups.  If the Admin has setup an External LDAP - all signups will assume that the username is an LDAP user. (Workaround - if somebody really want an internal username, the Admin will add for them or change their record from internal to external). (or) An alternative -there is a checkbox that says \"Authenticate against LDAP\" -this is checked on by  default.  If the user unchecks this, then the user gets created in the \"internal\" repo.  The new user cannot request an 'admin' role - but can only be granted the Admin privilege by another admin.  Password is not to be prompted for .   Candidate for v2 ? - workaround is an Admin adds every user to our User list. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_sign_up(username, display_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The user name for login (required)
        :param str display_name: The display name of user when logged in. (required)
        :param str email: The email of user when logged in.
        :param str password: The password for login in clear text
        :param str approval_status: If LDAP is set up with auto-signup, set this to \"enabled\"
        :param str authenticator: The authenticator for login in clear text
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.user_sign_up_with_http_info(username, display_name, **kwargs)
        else:
            (data) = self.user_sign_up_with_http_info(username, display_name, **kwargs)
            return data

    def user_sign_up_with_http_info(self, username, display_name, **kwargs):
        """
        User requesting access
        This option should only be shown if the user is not already logged in. The use provides their username and password.  We first validate if they have already signed up and if so - we show whether their status is pending/denied/approved etc.  If its ExternalLDAP - then we would validate that their entry exists in LDAP, by doing an ldap bind with their creds.  The user record is stored with 'approval_status' set to 'pending', for an admin to approve.  The config setting 'auto_signup' that automatically approves all signups.  If the Admin has setup an External LDAP - all signups will assume that the username is an LDAP user. (Workaround - if somebody really want an internal username, the Admin will add for them or change their record from internal to external). (or) An alternative -there is a checkbox that says \"Authenticate against LDAP\" -this is checked on by  default.  If the user unchecks this, then the user gets created in the \"internal\" repo.  The new user cannot request an 'admin' role - but can only be granted the Admin privilege by another admin.  Password is not to be prompted for .   Candidate for v2 ? - workaround is an Admin adds every user to our User list. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.user_sign_up_with_http_info(username, display_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The user name for login (required)
        :param str display_name: The display name of user when logged in. (required)
        :param str email: The email of user when logged in.
        :param str password: The password for login in clear text
        :param str approval_status: If LDAP is set up with auto-signup, set this to \"enabled\"
        :param str authenticator: The authenticator for login in clear text
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'display_name', 'email', 'password', 'approval_status', 'authenticator']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_sign_up" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params) or (params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `user_sign_up`")
        # verify the required parameter 'display_name' is set
        if ('display_name' not in params) or (params['display_name'] is None):
            raise ValueError("Missing the required parameter `display_name` when calling `user_sign_up`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'username' in params:
            form_params.append(('username', params['username']))
        if 'display_name' in params:
            form_params.append(('displayName', params['display_name']))
        if 'email' in params:
            form_params.append(('email', params['email']))
        if 'password' in params:
            form_params.append(('password', params['password']))
        if 'approval_status' in params:
            form_params.append(('approval_status', params['approval_status']))
        if 'authenticator' in params:
            form_params.append(('authenticator', params['authenticator']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/api/v1/usermgmt/signup', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def validate_user(self, **kwargs):
        """
        Almost an alias to the signin method. but intended for REST APIs
        For clients that cannot tolerate cookies or redirects and would prefer to use Basic auth headers or Bearer tokens instead. Intended to be invoked by our nginx proxy to seamlessly pass through the request to the right target url.  send out Authorization: Basic <base64ed username:password>  OR Authorization: Bearer <token> 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.validate_user(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The user name part in Basic Auth
        :param str password: The password part in Basic Auth
        :param str authorization: The bearer token part in Bearer Auth. 
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.validate_user_with_http_info(**kwargs)
        else:
            (data) = self.validate_user_with_http_info(**kwargs)
            return data

    def validate_user_with_http_info(self, **kwargs):
        """
        Almost an alias to the signin method. but intended for REST APIs
        For clients that cannot tolerate cookies or redirects and would prefer to use Basic auth headers or Bearer tokens instead. Intended to be invoked by our nginx proxy to seamlessly pass through the request to the right target url.  send out Authorization: Basic <base64ed username:password>  OR Authorization: Bearer <token> 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.validate_user_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str username: The user name part in Basic Auth
        :param str password: The password part in Basic Auth
        :param str authorization: The bearer token part in Bearer Auth. 
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'password', 'authorization']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_user" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'username' in params:
            header_params['username'] = params['username']
        if 'password' in params:
            header_params['password'] = params['password']
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/api/v1/usermgmt/validate', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
