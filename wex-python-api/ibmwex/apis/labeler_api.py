# coding: utf-8

"""
    WEX REST APIs

    Authentication methods - Basic Auth - JSON Web Token   - [POST /api/v1/usermgmt/login](#!/User/signinUser)   - [POST /api/v1/usermgmt/logout](#!/User/doLogout) - Python client sample [Download](/docs/wex-python-api.zip) 

    OpenAPI spec version: 12.0.2.417
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class LabelerApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def cancel_model_training(self, labeler_id, model_id, **kwargs):
        """
        Cancel labeler model training task
        Cancel labeler model training task
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_model_training(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: SimpleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.cancel_model_training_with_http_info(labeler_id, model_id, **kwargs)
        else:
            (data) = self.cancel_model_training_with_http_info(labeler_id, model_id, **kwargs)
            return data

    def cancel_model_training_with_http_info(self, labeler_id, model_id, **kwargs):
        """
        Cancel labeler model training task
        Cancel labeler model training task
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.cancel_model_training_with_http_info(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: SimpleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'model_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_model_training" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `cancel_model_training`")
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params) or (params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `cancel_model_training`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/{modelId}/task', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SimpleResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create(self, body, **kwargs):
        """
        Create a labeler
        Create a new labeler.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param InitLabeler body: (required)
        :return: Labeler
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_with_http_info(body, **kwargs)
        else:
            (data) = self.create_with_http_info(body, **kwargs)
            return data

    def create_with_http_info(self, body, **kwargs):
        """
        Create a labeler
        Create a new labeler.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param InitLabeler body: (required)
        :return: Labeler
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Labeler',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_collection(self, labeler_id, body, **kwargs):
        """
        Create and set a collection
        Create a collection to process the source dataset of the labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_collection(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param MLCollection body: (required)
        :return: Collection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_collection_with_http_info(labeler_id, body, **kwargs)
        else:
            (data) = self.create_collection_with_http_info(labeler_id, body, **kwargs)
            return data

    def create_collection_with_http_info(self, labeler_id, body, **kwargs):
        """
        Create and set a collection
        Create a collection to process the source dataset of the labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_collection_with_http_info(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param MLCollection body: (required)
        :return: Collection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_collection" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `create_collection`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_collection`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/collection', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Collection',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_model_from_source_dataset(self, labeler_id, body, **kwargs):
        """
        Create a labeler model
        Create and train a labeler model by separating the given source training dataset into training, validation, and test sets. About \"(For experts)\" parameters, refer [this](https://www.tensorflow.org/tutorials/wide#adding_regularization_to_prevent_overfitting) documentation.  Parameters used in training process can be set by adding config parameter of body  *Example*  For controlling training process   name | description  ---- | -----------  flag.batch_size | Int value. Batch size of examples per step  flag.max_steps | Int value. Max number of step for training  flag.val_monitor_every_n_steps |Int value. Step interval between validation  flag.val_monitor_early_stopping_rounds | Int value. Number of retry until cancel training (early stopping)  flag.early_stopping_improvement_ratio | loat value. Threshold of early stopping. The larger, the earlier trianing may stop.  For detailed model information*   name | description  ---- | -----------  flag.confusion_matrix_visible | True or False. Labelwise confusion matrix will be included. Currently only for classifier  flag.predictions_visible | True or False. Prediction results of documents in test dataset will be included. Currently only for classfier  flag.weights_visible | True or False. Weights of trained model will be included. Currenlty only for classifier 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_model_from_source_dataset(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param InitDatasetConfig body: Configuration to split the source training dataset (required)
        :param str resource_name: Name of the resource set created by this method
        :param str model_name: Name of the model created by this method
        :param float feature_threshold: Used during training a model. Threshold of the feature occurrences.  If this value is set at 2, metadata and words in text content fields occurred in only 1 document in the training set are not used as features.
        :param float label_threshold: Used during training a model. Threshold of the label occurrences.  If this value is set at 2, labels occurred in only 1 document in the training set are not used for the training and the prediction.
        :param float learning_rate: (For experts) Learning rate used in the training
        :param float prob_threshold: Used during using a deployed model. Threshold for the label prediction probabilities. If the predicted probability of a label is less than this value, the label is not included as the prediction result of this labeler in the runtime. A better value is calculcated and set while training.
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_model_from_source_dataset_with_http_info(labeler_id, body, **kwargs)
        else:
            (data) = self.create_model_from_source_dataset_with_http_info(labeler_id, body, **kwargs)
            return data

    def create_model_from_source_dataset_with_http_info(self, labeler_id, body, **kwargs):
        """
        Create a labeler model
        Create and train a labeler model by separating the given source training dataset into training, validation, and test sets. About \"(For experts)\" parameters, refer [this](https://www.tensorflow.org/tutorials/wide#adding_regularization_to_prevent_overfitting) documentation.  Parameters used in training process can be set by adding config parameter of body  *Example*  For controlling training process   name | description  ---- | -----------  flag.batch_size | Int value. Batch size of examples per step  flag.max_steps | Int value. Max number of step for training  flag.val_monitor_every_n_steps |Int value. Step interval between validation  flag.val_monitor_early_stopping_rounds | Int value. Number of retry until cancel training (early stopping)  flag.early_stopping_improvement_ratio | loat value. Threshold of early stopping. The larger, the earlier trianing may stop.  For detailed model information*   name | description  ---- | -----------  flag.confusion_matrix_visible | True or False. Labelwise confusion matrix will be included. Currently only for classifier  flag.predictions_visible | True or False. Prediction results of documents in test dataset will be included. Currently only for classfier  flag.weights_visible | True or False. Weights of trained model will be included. Currenlty only for classifier 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_model_from_source_dataset_with_http_info(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param InitDatasetConfig body: Configuration to split the source training dataset (required)
        :param str resource_name: Name of the resource set created by this method
        :param str model_name: Name of the model created by this method
        :param float feature_threshold: Used during training a model. Threshold of the feature occurrences.  If this value is set at 2, metadata and words in text content fields occurred in only 1 document in the training set are not used as features.
        :param float label_threshold: Used during training a model. Threshold of the label occurrences.  If this value is set at 2, labels occurred in only 1 document in the training set are not used for the training and the prediction.
        :param float learning_rate: (For experts) Learning rate used in the training
        :param float prob_threshold: Used during using a deployed model. Threshold for the label prediction probabilities. If the predicted probability of a label is less than this value, the label is not included as the prediction result of this labeler in the runtime. A better value is calculcated and set while training.
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'body', 'resource_name', 'model_name', 'feature_threshold', 'label_threshold', 'learning_rate', 'prob_threshold']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_model_from_source_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `create_model_from_source_dataset`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_model_from_source_dataset`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []
        if 'resource_name' in params:
            query_params.append(('resource-name', params['resource_name']))
        if 'model_name' in params:
            query_params.append(('model-name', params['model_name']))
        if 'feature_threshold' in params:
            query_params.append(('feature-threshold', params['feature_threshold']))
        if 'label_threshold' in params:
            query_params.append(('label-threshold', params['label_threshold']))
        if 'learning_rate' in params:
            query_params.append(('learning-rate', params['learning_rate']))
        if 'prob_threshold' in params:
            query_params.append(('prob-threshold', params['prob_threshold']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/all', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClassifierModel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete(self, labeler_id, **kwargs):
        """
        Delete a labeler
        Delete an existing labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: SimpleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_with_http_info(labeler_id, **kwargs)
        else:
            (data) = self.delete_with_http_info(labeler_id, **kwargs)
            return data

    def delete_with_http_info(self, labeler_id, **kwargs):
        """
        Delete a labeler
        Delete an existing labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_with_http_info(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: SimpleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `delete`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SimpleResponse',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get(self, labeler_id, **kwargs):
        """
        Show labeler details
        Show detailed information of an existing labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: Labeler
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_with_http_info(labeler_id, **kwargs)
        else:
            (data) = self.get_with_http_info(labeler_id, **kwargs)
            return data

    def get_with_http_info(self, labeler_id, **kwargs):
        """
        Show labeler details
        Show detailed information of an existing labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_with_http_info(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: Labeler
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Labeler',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_enrichment(self, labeler_id, model_id, **kwargs):
        """
        List enrichments where the labeler model deployed
        Show IDs of enrichments where the specified labeler model deployed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_enrichment(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: ListResponseString
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_enrichment_with_http_info(labeler_id, model_id, **kwargs)
        else:
            (data) = self.get_enrichment_with_http_info(labeler_id, model_id, **kwargs)
            return data

    def get_enrichment_with_http_info(self, labeler_id, model_id, **kwargs):
        """
        List enrichments where the labeler model deployed
        Show IDs of enrichments where the specified labeler model deployed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_enrichment_with_http_info(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: ListResponseString
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'model_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_enrichment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_enrichment`")
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params) or (params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_enrichment`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/{modelId}/enrichments', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListResponseString',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_enrichment_latest(self, labeler_id, **kwargs):
        """
        List enrichments where the latest labeler model deployed
        Show IDs of enrichments where the latest labeler model deployed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_enrichment_latest(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: ListResponseString
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_enrichment_latest_with_http_info(labeler_id, **kwargs)
        else:
            (data) = self.get_enrichment_latest_with_http_info(labeler_id, **kwargs)
            return data

    def get_enrichment_latest_with_http_info(self, labeler_id, **kwargs):
        """
        List enrichments where the latest labeler model deployed
        Show IDs of enrichments where the latest labeler model deployed.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_enrichment_latest_with_http_info(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: ListResponseString
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_enrichment_latest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_enrichment_latest`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/latest/enrichments', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListResponseString',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_model(self, labeler_id, model_id, **kwargs):
        """
        Show labeler model details
        Show detailed information of an existing labeler model
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_model(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_model_with_http_info(labeler_id, model_id, **kwargs)
        else:
            (data) = self.get_model_with_http_info(labeler_id, model_id, **kwargs)
            return data

    def get_model_with_http_info(self, labeler_id, model_id, **kwargs):
        """
        Show labeler model details
        Show detailed information of an existing labeler model
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_model_with_http_info(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'model_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_model`")
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params) or (params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_model`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/{modelId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClassifierModel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_model_latest(self, labeler_id, **kwargs):
        """
        Show the latest labeler model details
        Show detailed information of the latest model of the labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_model_latest(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_model_latest_with_http_info(labeler_id, **kwargs)
        else:
            (data) = self.get_model_latest_with_http_info(labeler_id, **kwargs)
            return data

    def get_model_latest_with_http_info(self, labeler_id, **kwargs):
        """
        Show the latest labeler model details
        Show detailed information of the latest model of the labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_model_latest_with_http_info(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_latest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_model_latest`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/latest', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClassifierModel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_model_status(self, labeler_id, model_id, **kwargs):
        """
        Show labeler model status
        Show status of the specified labeler model
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_model_status(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: ClassifierModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_model_status_with_http_info(labeler_id, model_id, **kwargs)
        else:
            (data) = self.get_model_status_with_http_info(labeler_id, model_id, **kwargs)
            return data

    def get_model_status_with_http_info(self, labeler_id, model_id, **kwargs):
        """
        Show labeler model status
        Show status of the specified labeler model
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_model_status_with_http_info(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: ClassifierModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'model_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_model_status`")
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params) or (params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_model_status`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/{modelId}/status', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClassifierModelStatus',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_resource_set(self, labeler_id, resource_set_id, **kwargs):
        """
        Show labeler resource set details
        Show detailed information of an existing labeler resource set
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_resource_set(labeler_id, resource_set_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str resource_set_id: The ID of the resource set. (required)
        :return: ResourceSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_resource_set_with_http_info(labeler_id, resource_set_id, **kwargs)
        else:
            (data) = self.get_resource_set_with_http_info(labeler_id, resource_set_id, **kwargs)
            return data

    def get_resource_set_with_http_info(self, labeler_id, resource_set_id, **kwargs):
        """
        Show labeler resource set details
        Show detailed information of an existing labeler resource set
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_resource_set_with_http_info(labeler_id, resource_set_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str resource_set_id: The ID of the resource set. (required)
        :return: ResourceSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'resource_set_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_resource_set`")
        # verify the required parameter 'resource_set_id' is set
        if ('resource_set_id' not in params) or (params['resource_set_id'] is None):
            raise ValueError("Missing the required parameter `resource_set_id` when calling `get_resource_set`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']
        if 'resource_set_id' in params:
            path_params['resourceSetId'] = params['resource_set_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/resources/{resourceSetId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ResourceSet',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_test_eval(self, labeler_id, model_id, **kwargs):
        """
        Show test evaluation result of the model
        Show test evaluation result of the specified labeler model.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_test_eval(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: LabelerEvalResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_test_eval_with_http_info(labeler_id, model_id, **kwargs)
        else:
            (data) = self.get_test_eval_with_http_info(labeler_id, model_id, **kwargs)
            return data

    def get_test_eval_with_http_info(self, labeler_id, model_id, **kwargs):
        """
        Show test evaluation result of the model
        Show test evaluation result of the specified labeler model.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_test_eval_with_http_info(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: LabelerEvalResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'model_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_test_eval" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_test_eval`")
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params) or (params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_test_eval`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/{modelId}/test', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LabelerEvalResult',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_test_evals(self, labeler_id, **kwargs):
        """
        List test evaluation results
        List test evaluation results of all models of the specified labeler.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_test_evals(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: ListResponseLabelerEvalResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_test_evals_with_http_info(labeler_id, **kwargs)
        else:
            (data) = self.get_test_evals_with_http_info(labeler_id, **kwargs)
            return data

    def get_test_evals_with_http_info(self, labeler_id, **kwargs):
        """
        List test evaluation results
        List test evaluation results of all models of the specified labeler.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_test_evals_with_http_info(labeler_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :return: ListResponseLabelerEvalResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_test_evals" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_test_evals`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/test-evals', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListResponseLabelerEvalResult',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_validation_eval(self, labeler_id, model_id, **kwargs):
        """
        Show validation evaluation result of the model
        Show validation evaluation result of the specified labeler model.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_validation_eval(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: LabelerEvalResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_validation_eval_with_http_info(labeler_id, model_id, **kwargs)
        else:
            (data) = self.get_validation_eval_with_http_info(labeler_id, model_id, **kwargs)
            return data

    def get_validation_eval_with_http_info(self, labeler_id, model_id, **kwargs):
        """
        Show validation evaluation result of the model
        Show validation evaluation result of the specified labeler model.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_validation_eval_with_http_info(labeler_id, model_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param str model_id: The ID of the model. (required)
        :return: LabelerEvalResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'model_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_validation_eval" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `get_validation_eval`")
        # verify the required parameter 'model_id' is set
        if ('model_id' not in params) or (params['model_id'] is None):
            raise ValueError("Missing the required parameter `model_id` when calling `get_validation_eval`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']
        if 'model_id' in params:
            path_params['modelId'] = params['model_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models/{modelId}/validation', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='LabelerEvalResult',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def list(self, **kwargs):
        """
        List labelers
        Display a list of existing labelers
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ListResponseLabeler
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_with_http_info(**kwargs)
        else:
            (data) = self.list_with_http_info(**kwargs)
            return data

    def list_with_http_info(self, **kwargs):
        """
        List labelers
        Display a list of existing labelers
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: ListResponseLabeler
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ListResponseLabeler',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_model(self, labeler_id, body, **kwargs):
        """
        Set a labeler model
        Set a labeler model to the labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_model(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param ClassifierModel body: (required)
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_model_with_http_info(labeler_id, body, **kwargs)
        else:
            (data) = self.set_model_with_http_info(labeler_id, body, **kwargs)
            return data

    def set_model_with_http_info(self, labeler_id, body, **kwargs):
        """
        Set a labeler model
        Set a labeler model to the labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_model_with_http_info(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param ClassifierModel body: (required)
        :return: ClassifierModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_model" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `set_model`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_model`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/models', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ClassifierModel',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def set_resource_set(self, labeler_id, body, **kwargs):
        """
        Set a labeler resource set
        Set a labeler resource set
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_resource_set(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param ResourceSet body: (required)
        :return: ResourceSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.set_resource_set_with_http_info(labeler_id, body, **kwargs)
        else:
            (data) = self.set_resource_set_with_http_info(labeler_id, body, **kwargs)
            return data

    def set_resource_set_with_http_info(self, labeler_id, body, **kwargs):
        """
        Set a labeler resource set
        Set a labeler resource set
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.set_resource_set_with_http_info(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param ResourceSet body: (required)
        :return: ResourceSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_resource_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `set_resource_set`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_resource_set`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}/resources', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='ResourceSet',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update(self, labeler_id, body, **kwargs):
        """
        Update a labeler
        Update an existing labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param Labeler body: (required)
        :return: Labeler
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_with_http_info(labeler_id, body, **kwargs)
        else:
            (data) = self.update_with_http_info(labeler_id, body, **kwargs)
            return data

    def update_with_http_info(self, labeler_id, body, **kwargs):
        """
        Update a labeler
        Update an existing labeler
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_with_http_info(labeler_id, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str labeler_id: The ID of the labeler. (required)
        :param Labeler body: (required)
        :return: Labeler
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['labeler_id', 'body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'labeler_id' is set
        if ('labeler_id' not in params) or (params['labeler_id'] is None):
            raise ValueError("Missing the required parameter `labeler_id` when calling `update`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update`")


        collection_formats = {}

        path_params = {}
        if 'labeler_id' in params:
            path_params['labelerId'] = params['labeler_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/api/v1/labelers/{labelerId}', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='Labeler',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
